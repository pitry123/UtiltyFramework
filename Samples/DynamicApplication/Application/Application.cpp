#include <Factories.hpp>
#include <Monitor.hpp>
#include <Dispatchers.hpp>
#include <Rules.hpp>
#include <INILoader.hpp>
#include <XMLLoader.hpp>
#include <DynamicApplication/ApplicationSampleDB.h>
#include <DynamicApplication/ProjectCommon.h>
#include <DynamicApplication/ParamStore.h>
#include <sstream>

using namespace Logging;

///  An application builder.
///  This is a sample app for dynamicApplication. It assumes that all data loading is done via the DataSet.XML
/// in order to execute it reqire command line argument
/// -f path to configuration file for factory configuration files (e.g. -f c:\Configuration\DynamicApplication\conf.xml)
/// -s path to the DataSet XML generated by DebugEnvironment this will create the database table and row and allows the name based sybscription and serialize a row to an XML
/// @date	11/12/2018
class ApplicationBuilder : public Application::Builder
{

public:
	ApplicationBuilder() :
		Builder()
	{
	}

private:
	Files::FilesHandler m_handler;
	Application::MainApp m_mainApp;
	Database::DataSet m_dataset;	
	Common::CommonTypes::MonitorParams m_debugEnv;
	Rules::RulesManager m_runnableRule;
	static Logger APP_LOGGER;
protected:
	Parsers::BinaryMetaData CreateThreeLayerNestedStruct()
	{
		Parsers::BinaryMetaData internal, nested;
		Parsers::BinaryMetadataStore store;
		Parsers::SimpleOptions options;
		Parsers::EnumData enumData = store.Enum("ComplexParser::MyEnum");
		if (enumData.Empty())
		{
			enumData = Parsers::EnumDataFactory::Create("ComplexParser::MyEnum");
			enumData.AddNewItem(0, "ENUM1");
			enumData.AddNewItem(1, "ENUM2");
			enumData.AddNewItem(2, "ENUM3");
			store.SetEnum("ComplexParser::MyEnum", enumData);
		}

		internal = store.Metadata("ThreeLayerNestedStruct::MyInternalStruct");
		if (internal.Empty())
		{
			options.minval<double>(1.3);
			options.maxval<double>(5.54);
			options.defval<double>(1.5);

			internal = Parsers::BinaryMetaDataBuilder::Create()
				.Namely("ThreeLayerNestedStruct::MyInternalStruct")
				.Simple<uint8_t>("a")
				.Simple<uint8_t>("b")
				.Buffer("test", 5)
				.Complex("internal", nested = Parsers::BinaryMetaDataBuilder::Create()
					.Namely("ThreeLayerNestedStruct::internalStruct")
					.Simple<float>("floatable")
					.Simple<double>("dobuleable", options));
		}

		options.minval<int>(5);
		options.maxval<int>(8);
		options.defval<int>(6);
		return Parsers::BinaryMetaDataBuilder::Create().
			Namely("ThreeLayerNestedStruct::ParentStruct").
			Simple<uint32_t>("a").
			Simple<int>("b", options).
			Complex("c", internal)
			.Array("InternalArray", 5, "ThreeLayerNestedStruct::internalStruct")
			.Simple<int>("j")
			.Enum("TheEnum", sizeof(int), "ComplexParser::MyEnum" ,Parsers::SimpleOptions())
			.String("str", 12);
	}
	virtual void BuildEnvironment() override
	{
		LOG_FUNC(APP_LOGGER);
		m_dataset = Database::MemoryDatabase::Create("MyDataBase");
		
		//Try to initialize the database from the dataset xml file - Naming Convension of DataSet is [ApplicationName]DataSet.XMl, this file is generated by the 
	    //Debug Environment
		std::string dbSchamPath = m_mainApp.DataBasePath() + m_mainApp.AppName() + "DataSet.xml";
		if (false == Database::Schema::Load(m_dataset, dbSchamPath))
		{
			Core::Console::ColorPrint(Core::Console::Colors::RED,"Failed to Build Environment from DataSet\n");
			throw std::runtime_error("error loading Data Set");
		}
		else
		{
			Core::Console::ColorPrint(Core::Console::Colors::GREEN, "Successfully Build Environment from XML Data Set \n");
		}
		
		try
		{
			//this will Work only if factory/user path is a valid path with conf.xml file
			ReadParamsStore();
		}
		catch (...)
		{
			//use default
			Core::Console::ColorPrint(Core::Console::Colors::YELLOW, "configuration files not found, error\n");
			throw std::runtime_error("error Loading Configuration");
		}

		std::stringstream os;
		os << "Build Monitor remote address " << m_debugEnv.remoteAddress << ":" << m_debugEnv.remotePort << " local address " << m_debugEnv.localAddress << ":" << m_debugEnv.localPort;
		LOG_INFO(APP_LOGGER) << os.str().c_str();
		Core::Console::ColorPrint(Core::Console::Colors::WHITE, "%s\n", os.str().c_str());
		
		Parsers::BinaryMetaData metadata = CreateThreeLayerNestedStruct();
		Database::RowInfo info;
		info.type = TypeEnum::COMPLEX;
		STRCPY(info.name, sizeof(info.name), "DynamicRow");
		STRCPY(info.type_name, sizeof(info.type_name), metadata.Namely());
		m_dataset[ProjectCommon::DynamicTable].AddRow(0,metadata.Size(), info, metadata);
		//create the monitor listener
		Parsers::BinaryMetadataStore store;

		std::string rulesPath = m_mainApp.DataBasePath() + m_mainApp.AppName()+ "Rules.xml";
		m_runnableRule = Rules::RulesBuilder::Create(rulesPath.c_str(), m_dataset,
			Parsers::BinaryMetadataStore());

		AddRunnable(m_runnableRule);
		AddRunnable<Database::Monitor>(m_debugEnv.remoteAddress, m_debugEnv.remotePort, m_debugEnv.localAddress, m_debugEnv.localPort, m_dataset,false,static_cast<core::parsers::binary_metadata_store_interface*>(store));
		AddRunnable<Database::Monitor>(m_debugEnv.remoteAddress, static_cast<uint16_t>(5678), m_debugEnv.localAddress, static_cast<uint16_t>(8765), m_dataset, false, static_cast<core::parsers::binary_metadata_store_interface*>(store));


	}

	virtual void BuildDispatchers() override
	{
		AddRunnable(Dispatchers::GreenDispatcher::Create(m_dataset.GetTableByName("GreenRedTable")));
		AddRunnable(Dispatchers::RedDispatcher::Create(m_dataset.GetTableByName("GreenRedTable")));
	}

	void ReadParamsStore()
	{
		std::string  xmlFactorySetting = "";
		std::string  xmlDeveloperSetting = "";
		std::string  xmlUserSetting = "";
		std::string  INIFilePath = "";
		m_handler = Files::FilesHandler::Create();
		
		//Check if files are already red by MainApp
		xmlFactorySetting = m_mainApp.FactorySettings();
		xmlDeveloperSetting = m_mainApp.DeveloperSettings();
		xmlUserSetting = m_mainApp.UserSettings();

		LOG_INFO(APP_LOGGER) << "Create XmlStoreDB";
		AddRunnable<ConfigurationLoader::XmlStoreDB>(ProjectCommon::MonitorDBIndex::XML_StoreDBEnum,
			m_dataset,
			xmlFactorySetting,
			xmlDeveloperSetting,
			xmlUserSetting,
			m_handler,
			m_mainApp.AppName(),
			m_mainApp.AppGroupName());
		

		m_dataset[ProjectCommon::MonitorDBIndex::XML_StoreDBEnum][ParamStore::XML_StoreDBEnum::DEBUG_ENV].Read<Common::CommonTypes::MonitorParams>(m_debugEnv);
	}
};

Logger ApplicationBuilder::APP_LOGGER = Core::Framework::CreateLogger("ApplicationBuilder", Severity::TRACE);

int main(int argc, const char* argv[])
{	
	try
	{
		Application::MainApp mainApp(argc, argv);
		return mainApp.BuildAndRun<ApplicationBuilder>();
	}
	catch (std::exception &e)
	{
        std::cout << "Error: " << e.what() << std::endl;
	}	
}
